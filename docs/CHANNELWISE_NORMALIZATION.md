# Поканальная нормализация (Channelwise Normalization)

## Обзор

Поканальная нормализация — это операция в пайплайне, которая применяет нормализацию **отдельно к каждому каналу** гиперспектрального куба, в отличие от обычной нормализации, которая работает со всеми данными как единым массивом.

---

## Разница между обычной и поканальной нормализацией

### Обычная нормализация (Глобальная)

```
1. Найти min и max по ВСЕМУ кубу
2. Нормализовать ВСЕ значения одинаково
```

**Пример:**
```
Куб: 512×217×204 (H×W×C)
Канал 0: значения 0-100
Канал 100: значения 500-1000
Канал 203: значения 50-200

Min-Max нормализация:
Global min = 0, Global max = 1000
→ Все каналы нормализуются относительно [0, 1000]
```

**Проблема:** Каналы с малым диапазоном (0-100) теряют контраст!

### Поканальная нормализация

```
1. Для каждого канала ОТДЕЛЬНО:
   - Найти min и max ЭТОГО канала
   - Нормализовать значения ЭТОГО канала
2. Повторить для всех каналов
```

**Пример:**
```
Канал 0: min=0, max=100 → нормализовать [0, 100] → [0, 1]
Канал 100: min=500, max=1000 → нормализовать [500, 1000] → [0, 1]
Канал 203: min=50, max=200 → нормализовать [50, 200] → [0, 1]
```

**Результат:** Каждый канал использует полный диапазон [0, 1] ✅

---

## Когда использовать

### ✅ Используйте поканальную нормализацию если:

1. **Разные единицы измерения в каналах**
   - ENVI файлы с reflectance (0-1) и radiance (0-10000) в одном кубе
   - Смешанные типы данных после пайплайна

2. **Нестабильная калибровка**
   - Разные каналы имеют разные амплитуды из-за настроек сенсора
   - Шум или артефакты в отдельных каналах

3. **Спектральный анализ**
   - Нужно сравнивать форму спектра, а не абсолютные значения
   - PCA, ICA, спектральное unmixing

4. **Улучшение визуализации**
   - Хотите видеть детали в КАЖДОМ канале отдельно
   - Создание RGB композитов из каналов с разными диапазонами

### ❌ НЕ используйте поканальную нормализацию если:

1. **Важны абсолютные значения**
   - Физические измерения (температура, влажность)
   - Калиброванные данные где соотношения между каналами важны

2. **Классификация/регрессия**
   - Модели ML обучены на данных с глобальной нормализацией
   - Нужно сохранить относительные различия между каналами

3. **Все каналы в одном диапазоне**
   - Данные уже хорошо откалиброваны
   - Глобальная нормализация работает нормально

---

## Доступные типы нормализации

Все типы из обычной нормализации:

### 1. Min-Max (0-1)
```
Для каждого канала:
  min_ch = min(channel_values)
  max_ch = max(channel_values)
  normalized = (value - min_ch) / (max_ch - min_ch)
```

### 2. Min-Max (custom)
```
Для каждого канала:
  min_ch = min(channel_values)
  max_ch = max(channel_values)
  normalized = targetMin + (value - min_ch) / (max_ch - min_ch) * (targetMax - targetMin)
```

### 3. Percentile
```
Для каждого канала:
  sort(channel_values)
  lower = percentile(channel, 2%)
  upper = percentile(channel, 98%)
  normalized = clip(value, lower, upper) / (upper - lower)
```

### 4. Z-Score
```
Для каждого канала:
  mean_ch = mean(channel_values)
  std_ch = std(channel_values)
  normalized = (value - mean_ch) / std_ch
```

### 5. Log
```
Для каждого канала:
  normalized = log(value + 1)
```

### 6. Sqrt
```
Для каждого канала:
  normalized = sqrt(value)
```

---

## Использование

### Шаг 1: Добавить в пайплайн

```
Панель пайплайна → "+" → "Поканальная нормализация"
```

### Шаг 2: Настроить параметры

```
Нажать ✏️ (карандаш) на операции
→ Выбрать тип нормализации
→ Настроить параметры (если нужно)
→ Нажать "Готово"
```

### Шаг 3: Применить

```
Режим ⚡ (Auto): применяется автоматически
Режим ✋ (Manual): нажать "Применить"
```

---

## Примеры

### Пример 1: ENVI файл с разными диапазонами

```
Проблема:
  Канал 0 (Blue, 450nm): 0-0.2 (reflectance)
  Канал 100 (Red, 650nm): 0-0.8 (reflectance)
  Канал 200 (NIR, 850nm): 0.1-1.5 (reflectance)

Решение:
1. Открыть ENVI файл
2. Пайплайн → "Поканальная нормализация"
3. Тип: Min-Max (0-1)
4. ✅ Каждый канал теперь в [0, 1]

Результат:
  Все каналы имеют полный контраст
  Визуализация улучшена
  Готово для PCA/ICA
```

### Пример 2: Подготовка для спектрального unmixing

```
Задача:
  Unmixing требует чтобы форма спектра была важнее абсолютных значений

Пайплайн:
1. Поканальная нормализация → Z-Score
   (Каждый канал: mean=0, std=1)
2. Обычная нормализация → Min-Max (0-1)
   (Всё в положительный диапазон)
3. Тип данных → Float32
4. Экспорт → NPY

Результат:
  Спектры нормализованы по форме
  Готово для unmixing алгоритмов
```

### Пример 3: RGB композит из произвольных каналов

```
Задача:
  Создать RGB из каналов 30, 60, 90
  Эти каналы имеют разные амплитуды

Пайплайн:
1. Поканальная нормализация → Min-Max (0-255)
2. Тип данных → UInt8
3. Визуализация → RGB mode
4. Выбрать каналы вручную: R=30, G=60, B=90

Результат:
  Сбалансированное RGB изображение
  Все три канала с полным контрастом
```

### Пример 4: Сравнение до/после

```
До (Глобальная):
  Открыть куб
  Нормализация → Min-Max (0-1)
  Канал 50: тусклый, малоконтрастный
  Канал 100: яркий, хороший контраст
  Канал 150: тусклый

После (Поканальная):
  Открыть куб
  Поканальная нормализация → Min-Max (0-1)
  Канал 50: яркий, высокий контраст ✅
  Канал 100: яркий, высокий контраст ✅
  Канал 150: яркий, высокий контраст ✅
```

---

## Технические детали

### Алгоритм

```swift
func applyChannelwise(type, cube, parameters) -> HyperCube {
    for each channel in cube.channels:
        // 1. Извлечь данные канала
        channelData = extractChannel(cube, channelIndex)
        
        // 2. Применить нормализацию к этому каналу
        normalizedChannel = normalize(channelData, type, parameters)
        
        // 3. Записать обратно
        writeChannel(cube, channelIndex, normalizedChannel)
    
    return cube
}
```

### Производительность

- **Время:** O(H × W × C) — линейное, как глобальная нормализация
- **Память:** Дополнительно O(H × W) для хранения одного канала
- **Параллелизация:** Каждый канал независим → можно параллелить (будущее улучшение)

### Сохранение типа данных

Работает так же как в обычной нормализации:

```
☑️ Сохранить тип данных

Если все каналы после нормализации в диапазоне [0, 255]:
  → Сохранить как UInt8
Если в [0, 65535]:
  → Сохранить как UInt16
Иначе:
  → Float64
```

---

## Сравнение с другими операциями

| Операция | Область | Когда использовать |
|----------|---------|-------------------|
| **Нормализация** | Весь куб | Данные однородны, нужны абсолютные отношения |
| **Поканальная нормализация** | Каждый канал | Разные диапазоны, нужна форма спектра |
| **Тип данных** | Весь куб | Изменение типа, экономия памяти |

---

## Комбинации в пайплайне

### Рекомендуемые:

✅ **Поканальная → Обычная**
```
1. Поканальная Min-Max (0-1)  // Выровнять каналы
2. Обычная Min-Max (0-255)    // Подготовить для UInt8
3. UInt8                       // Экономия памяти
```

✅ **Поканальная → Тип**
```
1. Поканальная Z-Score        // Стандартизировать каждый канал
2. Float32                     // Уменьшить память
```

### Не рекомендуемые:

❌ **Обычная → Поканальная**
```
1. Обычная Min-Max (0-1)       // Выровняет весь куб
2. Поканальная Min-Max (0-1)   // Бессмысленно: все уже в [0,1]
```

❌ **Поканальная → Поканальная**
```
1. Поканальная Min-Max
2. Поканальная Z-Score         // Лучше сделать одну операцию
```

---

## Ограничения

1. **Теряются абсолютные отношения между каналами**
   - Канал с малыми значениями будет выглядеть так же ярко как с большими
   - Не подходит для количественного анализа

2. **Зависимость от данных в канале**
   - Если канал содержит выбросы → влияет на весь канал
   - Используйте Percentile для устойчивости

3. **Не подходит для некоторых ML задач**
   - Модели могут ожидать глобальную нормализацию
   - Проверьте требования вашей модели

---

## См. также

- [NORMALIZATION_FEATURE.md](NORMALIZATION_FEATURE.md) - Обычная нормализация
- [PIPELINE_SYSTEM.md](PIPELINE_SYSTEM.md) - Система пайплайнов
- [DATA_TYPE_CONVERSION.md](DATA_TYPE_CONVERSION.md) - Конвертация типов

---

**Версия:** v0.4+  
**Дата:** 2025-11-29  
**Автор:** HSIView Team


