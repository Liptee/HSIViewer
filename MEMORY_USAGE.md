# Использование памяти в HSIView

## Почему файл 2 ГБ занимает 20 ГБ в памяти?

### Короткий ответ

Все данные конвертируются в `Double` (8 байт) для универсальности и точности вычислений.

### Детальное объяснение

#### Пример: `uint8 (7958, 1280, 250)`

**На диске (NPY файл):**
- Тип данных: `uint8` (1 байт на элемент)
- Элементов: `7958 × 1280 × 250 = 2,547,200,000`
- Размер файла: `2,547,200,000 × 1 байт = 2.4 ГБ`

**В памяти приложения:**
- Тип данных: `Double` (8 байт на элемент)
- Элементов: `2,547,200,000`
- Размер в памяти: `2,547,200,000 × 8 байт = 19.2 ГБ`

**Коэффициент: 8x** (для uint8)

#### Коэффициенты для разных типов:

| Тип на диске | Размер | Double | Коэффициент |
|-------------|--------|--------|-------------|
| `uint8` | 1 байт | 8 байт | **8x** |
| `uint16` | 2 байт | 8 байт | **4x** |
| `int32` | 4 байт | 8 байт | **2x** |
| `float32` | 4 байт | 8 байт | **2x** |
| `float64` | 8 байт | 8 байт | **1x** (без увеличения) |

### Почему Double?

#### ✅ Преимущества:

1. **Универсальность**
   - Один код для всех типов данных
   - Не нужно дублировать логику для каждого типа
   - Упрощение архитектуры

2. **Точность вычислений**
   - Нет потери точности при операциях
   - Правильная нормализация
   - Корректная статистика (среднее, std)

3. **Совместимость с macOS**
   - NSImage работает с CGFloat (Double на 64-bit)
   - Core Graphics использует Double для координат
   - SwiftUI использует Double для размеров

4. **Поддержка всех значений**
   - Может хранить значения от `int64` до `float64` без потерь
   - Поддержка отрицательных значений
   - Поддержка дробных значений

#### ❌ Недостатки:

1. **Высокое потребление памяти**
   - 8x для uint8
   - 4x для uint16
   - 2x для float32

2. **Медленная загрузка**
   - Требуется конвертация каждого элемента
   - Дополнительные аллокации памяти

3. **Ограничение размера файлов**
   - Зависит от доступной RAM
   - uint8 файл на 10 ГБ → 80 ГБ в памяти (не реалистично)

## Временное использование памяти

### При загрузке с переупорядочиванием (Fortran → C)

```
Шаг 1: Загрузка из файла
  File data (uint8): 2.4 ГБ
  
Шаг 2: Конвертация в Double
  Double array: 19.2 ГБ
  Итого: 2.4 + 19.2 = 21.6 ГБ
  
Шаг 3: Переупорядочивание (если Fortran-order)
  Old Double array: 19.2 ГБ
  New Double array: 19.2 ГБ
  Итого: 2.4 + 19.2 + 19.2 = 40.8 ГБ (ПИК!)
  
Шаг 4: Очистка
  File data освобождается: -2.4 ГБ
  Old array освобождается: -19.2 ГБ
  Итого: 19.2 ГБ (финальное использование)
```

**Вывод:** Пиковое использование памяти может быть **до 2x от финального** при Fortran-order файлах!

## Рекомендации

### Для пользователей:

1. **Проверьте доступную память**
   - Для файла 2 ГБ (uint8) нужно ~40 ГБ свободной RAM
   - Закройте другие приложения перед загрузкой больших файлов

2. **Конвертируйте в float64 заранее**
   - Файл станет больше (8x), но загрузка быстрее
   - Нет пикового использования при переупорядочивании
   ```python
   import numpy as np
   data = np.load('file_uint8.npy')
   data_f64 = data.astype(np.float64)
   np.save('file_float64.npy', data_f64)
   ```

3. **Используйте C-order**
   - Избегайте Fortran-order для больших файлов
   - Конвертация:
   ```python
   data = np.load('file_fortran.npy')
   data_c = np.ascontiguousarray(data)  # конвертация в C-order
   np.save('file_c_order.npy', data_c)
   ```

### Для разработчиков:

См. `NPY_FORTRAN_ORDER_FIX.md` → раздел "Возможные оптимизации"

## Альтернативные подходы (будущие версии)

### 1. Ленивая загрузка (Memory-mapped files)

```swift
// Вместо загрузки всего файла:
let data = try Data(contentsOf: url)  // 2 ГБ в память

// Использовать mmap:
let file = try FileHandle(forReadingFrom: url)
let mappedData = file.map()  // ~0 МБ в память (только метаданные)
```

Преимущества:
- Минимальное использование памяти
- Быстрый старт приложения
- Поддержка файлов >RAM

Недостатки:
- Медленнее при просмотре (чтение с диска)
- Сложнее реализация
- Требует оптимизации кэширования

### 2. Tile-based рендеринг

Загрузка и обработка только видимой части изображения:

```
Файл: 7958 × 1280 × 250 = 2.4 ГБ
Видимо на экране: 2048 × 1280 × 3 (RGB) ≈ 60 МБ
Загрузка: только нужные строки × нужные каналы
```

Преимущества:
- Работа с файлами любого размера
- Низкое использование памяти
- Быстрый отклик UI

Недостатки:
- Очень сложная реализация
- Требует индексирования файла
- Медленные операции над всем кубом

### 3. Сохранение оригинального типа

```swift
struct HyperCube {
    enum Storage {
        case uint8([UInt8])
        case uint16([UInt16])
        case float32([Float])
        case float64([Double])
    }
    let storage: Storage
}
```

Преимущества:
- Экономия памяти (1x вместо 8x для uint8)
- Быстрая загрузка

Недостатки:
- Сложность кода (дублирование логики)
- Нужна конвертация при операциях
- Потенциальные баги из-за разных путей кода

## Текущее состояние

**Версия:** 0.2.x

**Стратегия:** Простота > Память

Мы выбрали простоту реализации и универсальность за счет высокого использования памяти. Это подходит для:

✅ Малых и средних файлов (<1 ГБ на диске = <8 ГБ в памяти)
✅ Систем с большим объемом RAM (32+ ГБ)
✅ Быстрой разработки и добавления фич

❌ Не подходит для очень больших файлов (>5 ГБ на диске)
❌ Не подходит для систем с малым RAM (<16 ГБ)

## Итоги

| Аспект | Текущая реализация | Будущие оптимизации |
|--------|-------------------|---------------------|
| Память для uint8 | **8x от размера файла** | 1x (original type) / ~0x (mmap) |
| Пик при Fortran | **~2x финального** | Избегается (streaming) |
| Скорость загрузки | Средняя | Быстрее (no conversion) / Instant (mmap) |
| Сложность кода | Низкая | Средняя-Высокая |
| Макс. размер файла | ~RAM/8 для uint8 | Неограничен (mmap) |

---

**Дата:** 2025-11-28
**Связанные документы:**
- `NPY_LARGE_FILES_FIX.md` - оптимизация чтения
- `NPY_FORTRAN_ORDER_FIX.md` - переупорядочивание данных

