# Исправление Fortran-order для NPY файлов

## Проблема

NPY файлы с Fortran-order (column-major) отображались некорректно - с вертикальными полосами вместо правильного изображения.

## Причина

### Fortran-order vs C-order

NumPy поддерживает два порядка хранения многомерных массивов:

**C-order (row-major, по умолчанию):**
```python
arr = np.array([[[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]]])  # shape (2,2,3)
# В памяти: [1,2,3, 4,5,6, 7,8,9, 10,11,12]
# Последний индекс меняется быстрее всего
```

**Fortran-order (column-major):**
```python
arr = np.array([[[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]]], order='F')
# В памяти: [1,7, 4,10, 2,8, 5,11, 3,9, 6,12]
# Первый индекс меняется быстрее всего
```

### Индексация для shape (H, W, C):

**C-order:**
```
Индекс элемента [h, w, c] = c + C * (w + W * h)
Порядок в памяти: [0,0,0], [0,0,1], [0,0,2], ..., [0,0,C-1], [0,1,0], ...
```

**Fortran-order:**
```
Индекс элемента [h, w, c] = h + H * (w + W * c)
Порядок в памяти: [0,0,0], [1,0,0], [2,0,0], ..., [H-1,0,0], [0,1,0], ...
```

### Проблема в коде

Наш `ImageRenderer` ожидает данные в C-order, но мы игнорировали флаг `fortranOrder` при загрузке NPY файлов. Это приводило к неправильной интерпретации данных.

## Решение

Добавлена функция `reorderFromFortranToC()`, которая переупорядочивает данные из Fortran-order в C-order при загрузке:

```swift
private static func reorderFromFortranToC(values: [Double], dims: (Int, Int, Int)) -> [Double] {
    let (H, W, C) = dims
    var reordered = [Double](repeating: 0.0, count: values.count)
    
    for h in 0..<H {
        for w in 0..<W {
            for c in 0..<C {
                let fortranIndex = h + H * (w + W * c)
                let cIndex = c + C * (w + W * h)
                reordered[cIndex] = values[fortranIndex]
            }
        }
    }
    
    return reordered
}
```

Функция вызывается только если `header.fortranOrder == true` и массив 3D.

## Использование памяти

### Почему файл 2 ГБ занимает 20 ГБ в памяти?

**Исходный файл:**
- Тип: `uint8`
- Shape: `(7958, 1280, 250)`
- Элементов: `7958 × 1280 × 250 = 2,547,200,000`
- Размер: `2,547,200,000 × 1 байт = 2.4 ГБ`

**В памяти приложения:**
- Тип: `Double` (для универсальности)
- Элементов: `2,547,200,000`
- Размер: `2,547,200,000 × 8 байт = 19.2 ГБ`

**Временно при переупорядочивании:**
- Старый массив: 19.2 ГБ
- Новый массив: 19.2 ГБ
- **Пик: ~38 ГБ** (затем старый массив освобождается)

### Почему Double?

Все типы данных (float32/64, int8/16/32, uint8/16) конвертируются в `Double` для:

✅ **Универсальность**: один код обработки для всех типов
✅ **Точность**: нет потери точности при вычислениях
✅ **Совместимость**: NSImage работает с нормализованными Double

❌ **Недостаток**: высокое потребление памяти (8x для uint8)

## Возможные оптимизации (будущие)

### 1. Сохранение оригинального типа

```swift
struct HyperCube {
    let dims: (Int, Int, Int)
    let dataUInt8: [UInt8]?  // для uint8
    let dataDouble: [Double]?  // для float
    // ...
}
```

Преимущества: экономия памяти (8x для uint8)
Недостатки: сложность кода, дублирование логики

### 2. Memory-mapped файлы

Загрузка данных по требованию вместо полной загрузки в память.

Преимущества: минимальное использование памяти
Недостатки: медленнее при просмотре

### 3. Tile-based рендеринг

Загрузка и обработка только видимой части изображения.

Преимущества: работа с файлами любого размера
Недостатки: сложная реализация

## Тестирование

### Создание тестового Fortran-order файла:

```python
import numpy as np

# C-order (по умолчанию)
data_c = np.random.randint(0, 255, (100, 200, 3), dtype=np.uint8)
np.save('test_c_order.npy', data_c)
print(f"C-order: {data_c.flags['C_CONTIGUOUS']}, {data_c.flags['F_CONTIGUOUS']}")

# Fortran-order
data_f = np.asfortranarray(data_c)
np.save('test_f_order.npy', data_f)
print(f"F-order: {data_f.flags['C_CONTIGUOUS']}, {data_f.flags['F_CONTIGUOUS']}")
```

### Проверка:

1. Откройте оба файла в приложении
2. Изображения должны выглядеть идентично
3. Информационная панель должна показывать одинаковые характеристики

## Файлы изменены

- `HSIView/Services/NpyImageLoader.swift`:
  - Добавлена функция `reorderFromFortranToC()`
  - Добавлена проверка `header.fortranOrder` и вызов переупорядочивания

## Дата

2025-11-28

