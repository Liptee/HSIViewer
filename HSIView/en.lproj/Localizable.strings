"common.cancel" = "Cancel";
"common.done" = "Done";
"common.remove" = "Remove";
"common.open" = "Open";
"common.ok" = "OK";
"common.apply" = "Apply";
"common.save" = "Save";
"units.nm" = "nm";
"units.size.gb" = "%.2f GB";
"units.size.mb" = "%.1f MB";

"content_view.open_cube" = "Open HSI";

"menu.access_manager" = "Access Manager…";
"menu.assemble_hsi" = "Assemble HSI";
"menu.create_from_current" = "Create from Current";
"menu.export" = "Export…";
"menu.graph" = "Graph";
"menu.grid_library" = "Grid Library";
"menu.language" = "Language";
"menu.language.english" = "English";
"menu.language.russian" = "Russian";
"menu.language.system" = "System";
"menu.main_window" = "Main Window";
"menu.open" = "Open…";
"menu.import_mask" = "Import Mask…";
"menu.propagate_processing" = "Propagate Processing";
"menu.propagate_wavelengths" = "Propagate Wavelengths";
"menu.show_left_panel" = "Show Left Panel";
"menu.show_right_panel" = "Show Right Panel";

"library.title" = "Library";
"library.drop_release_to_add" = "Drop to add";
"library.empty_hint" = "Drag .mat, .tiff, .npy, or .dat files here to add them to the library. Double-click an item to open the cube.";
"library.rename_cube.title" = "Rename Cube";
"library.rename_cube.field_name" = "Name";
"library.rename_cube.message" = "Enter a new name for the selected cube.";
"library.context.copy_processing" = "Copy Processing";
"library.context.paste_processing" = "Paste Processing";
"library.context.copy_wavelengths" = "Copy Wavelengths";
"library.context.paste_wavelengths" = "Paste Wavelengths";
"library.context.paste_point" = "Paste Point";
"library.context.paste_area" = "Paste Area";
"library.context.copy_points_areas" = "Copy Points and Areas";
"library.context.paste_points_areas" = "Paste Points and Areas";
"library.context.rename" = "Rename…";
"library.context.remove_from_library" = "Remove from Library";
"library.wavelength.unset" = "lambda: range not set";
"library.wavelength.single" = "lambda: %.1f nm • %d channel(s)";
"library.wavelength.range" = "lambda: %.1f - %.1f nm • %d channel(s)";

"grid.title" = "Grid Library";
"grid.sidebar.hsi" = "HSI";
"grid.sidebar.release_to_import" = "Drop to import";
"grid.sidebar.empty_library" = "Drag .mat, .tiff, .npy, or .dat files to add HSI data to the library.";
"grid.sidebar.all_assigned" = "All entries are already placed in the grid. Remove an item from a cell or delete a row/column to return it to this list.";
"grid.header.counts" = "%d row(s) • %d column(s)";
"grid.empty_state.title" = "Table is not ready yet";
"grid.create_row" = "Create Row";
"grid.create_column" = "Create Column";
"grid.help.add_column" = "Add column";
"grid.help.add_row" = "Add row";
"grid.add_row" = "Add Row";
"grid.context.rename" = "Rename…";
"grid.context.move_left" = "Move Left";
"grid.context.move_right" = "Move Right";
"grid.context.move_up" = "Move Up";
"grid.context.move_down" = "Move Down";
"grid.context.delete_column" = "Delete Column";
"grid.context.delete_row" = "Delete Row";
"grid.context.return_to_library" = "Return to Library";
"grid.context.group.items_count" = "Items in group: %d";
"grid.context.group.empty" = "Group is empty";
"grid.context.group.return_to_library" = "Return Group to Library";
"grid.cell.empty" = "Empty";
"grid.rename_row.title" = "Rename Row";
"grid.rename_row.field_name" = "Row Name";
"grid.rename_row.message" = "Enter a new row name.";
"grid.rename_column.title" = "Rename Column";
"grid.rename_column.field_name" = "Column Name";
"grid.rename_column.message" = "Enter a new column name.";
"grid.row.default_name" = "Row %d";
"grid.column.default_name" = "Column %d";

"window.graph.title" = "Graph";
"window.grid_library.title" = "Grid Library";
"window.assembler.title" = "Assembler";

"access.title" = "Access Manager";
"access.empty.saved_none" = "No saved access entries";
"access.empty.add_hint" = "Add a folder to avoid repeated access prompts";
"access.status.active" = "Access active";
"access.status.lost" = "Access lost";
"access.add_folder" = "Add Folder…";
"access.alert.save_failed.title" = "Failed to save access";
"access.alert.save_failed.message" = "Try selecting another folder or check access permissions.";
"access.panel.select_folder.message" = "Select a folder to keep permanent access";
"access.panel.select_folder.prompt_add" = "Add";

"datatype.title" = "Data Type";
"datatype.current_type" = "Current type: %@";
"datatype.convert_to" = "Convert to:";
"datatype.scaling" = "Scaling:";
"datatype.scaling.auto" = "Automatic";
"datatype.scaling.auto_hint" = "Data will be scaled to target type range";
"datatype.scaling.clamp_hint" = "Values will be clamped";
"datatype.memory_size" = "Memory size";
"datatype.after_conversion" = "After conversion";
"datatype.change" = "Change";

"imageinfo.title" = "Image Info";
"imageinfo.format" = "Format";
"imageinfo.data_type" = "Data type";
"imageinfo.kind" = "Type";
"imageinfo.kind.2d" = "2D image";
"imageinfo.size" = "Size";
"imageinfo.resolution" = "Resolution";
"imageinfo.channels" = "Channels";
"imageinfo.min_value" = "Min value";
"imageinfo.max_value" = "Max value";
"imageinfo.mean_value" = "Mean";
"imageinfo.std_dev" = "Std. dev.";
"imageinfo.memory_size" = "Memory size";
"imageinfo.geo.crs" = "CRS";
"imageinfo.geo.pixel_size" = "Pixel size";
"imageinfo.geo.rotation" = "Rotation";
"imageinfo.geo.cursor_pixel" = "Cursor pixel";
"imageinfo.geo.map_x" = "Map X";
"imageinfo.geo.map_y" = "Map Y";
"imageinfo.geo.longitude" = "Longitude";
"imageinfo.geo.latitude" = "Latitude";

"mat.select_variable.title" = "Select variable to import";

"normalization.title" = "Normalization";
"normalization.type" = "Type";
"normalization.precision" = "Precision:";
"normalization.float32_result_hint" = "Normalization result will be saved as Float32";
"normalization.parameters" = "Parameters:";
"normalization.source_range" = "Source range:";
"normalization.target_range" = "Target range:";
"normalization.lower_percent" = "Lower %:";
"normalization.upper_percent" = "Upper %:";

"rangewide.title" = "Color synthesis ranges";
"rangewide.wavelengths_unavailable" = "Wavelengths are unavailable — set channel ranges with the slider.";
"rangewide.range_available" = "Lambda range: %@ - %@ nm";
"rangewide.range_no_data" = "Lambda range: no data";
"rangewide.channels_summary" = "Channels %d-%d • lambda %@-%@ nm • %d channels";
"rangewide.range_info_with_wavelength" = "%@: ch %d-%d (lambda %@-%@ nm, %d channels)";
"rangewide.range_info_channels_only" = "%@: ch %d-%d (%d channels)";

"content_view.open_cube" = "Open a hyperspectral cube";
"content_view.empty_hint" = "Your ad could be here";

"Выполнение…" = "Processing…";
"Выбрать папку" = "Choose Folder";
"Выберите папку для сохранения экспортированных файлов библиотеки" = "Choose a folder to save exported library files";
"Выберите путь для сохранения" = "Choose save location";
"Выберите путь для сохранения PNG изображения" = "Choose save location for PNG image";
"Выберите путь для сохранения TIFF" = "Choose save location for TIFF";
"Выбрать .txt файл…" = "Choose .txt file…";
"Выбрать txt" = "Choose txt";
"Выбрать все" = "Select all";
"Готово" = "Done";
"Длины волн" = "Wavelengths";
"Каналы цветосинтеза" = "Color synthesis channels";
"ND индексы" = "ND indices";
"Пресет" = "Preset";
"Палитра" = "Palette";
"Порог ND" = "ND threshold";
"Red (нм)" = "Red (nm)";
"NIR (нм)" = "NIR (nm)";
"Green (нм)" = "Green (nm)";
"SWIR (нм)" = "SWIR (nm)";
"Автооценка почвы…" = "Soil auto-estimation…";
"Автооценка линии почвы (WDVI)" = "Soil-line auto-estimation (WDVI)";
"Сохранённых ROI нет — добавьте области на изображении и повторите." = "No saved ROI. Add regions on the image and try again.";
"ROI для оценки" = "ROI for estimation";
"Очистить" = "Clear";
"Фильтрация и регрессия" = "Filtering and regression";
"Обрезка по перцентилям" = "Percentile clipping";
"Нижний" = "Lower";
"Верхний" = "Upper";
"Отсечение по z-score" = "Z-score clipping";
"Метод регрессии" = "Regression method";
"Отмена" = "Cancel";
"Рассчитать" = "Calculate";
"Область расчёта PCA" = "PCA calculation scope";
"Маппинг компонентов → RGB" = "Component mapping -> RGB";
"ROI для PCA" = "ROI for PCA";
"Нет сохранённых ROI" = "No saved ROI";
"Отрезать верхние выбросы" = "Clip upper outliers";
"Применить PCA" = "Apply PCA";
"Обработка…" = "Processing…";
"Настройте параметры и нажмите «Применить»" = "Configure parameters and click \"Apply\"";
"Нажмите «Применить PCA»" = "Click \"Apply PCA\"";
"Не удалось построить изображение" = "Failed to render image";
"Не удалось построить RGB изображение" = "Failed to render RGB image";
"Не удалось построить ND" = "Failed to render ND";
"Файл не выбран" = "No file selected";
"Центрировать" = "Center";
"Режим: 2D изображение" = "Mode: 2D image";
"λ не заданы" = "Wavelengths are not set";
"Настройка длин волн" = "Wavelength setup";
"Диапазон (нм):" = "Range (nm):";
"от" = "from";
"до" = "to";
"Применить диапазон" = "Apply range";
"Или загрузить из файла:" = "Or load from file:";
"Текущие значения:" = "Current values:";
"Экспорт библиотеки" = "Library export";
"Экспорт библиотеки завершён" = "Library export completed";
"Экспорт выполнен с ошибками" = "Export completed with errors";
"Ошибка экспорта" = "Export error";
"Все файлы успешно экспортированы" = "All files exported successfully";
"При экспорте возникли ошибки" = "Errors occurred during export";
"Перетащите точки" = "Drag points";
"(эталон)" = "(reference)";

"График спектра" = "Spectrum graph";
"График спектра ROI" = "ROI spectrum graph";
"Линейка" = "Ruler";
"ruler.overlay.pixels" = "Pixels: %@ px";
"ruler.overlay.distance" = "Distance: %@";
"ruler.overlay.distance_unit" = "Distance: %@ %@";
"ruler.unit.m" = "m";
"ruler.unit.km" = "km";
"Нет сохранённых точек" = "No saved points";
"Сохранено: %lld" = "Saved: %lld";
"Нет сохранённых областей" = "No saved regions";
"Областей: %lld" = "Regions: %lld";
"Инструмент не выбран" = "No tool selected";
"Выберите инструмент" = "Choose a tool";
"Активируйте анализ в доке сверху" = "Enable analysis in the top dock";
"Кликните на изображение" = "Click on the image";
"чтобы увидеть спектр пикселя" = "to view pixel spectrum";
"Нарисуйте область на изображении" = "Draw a region on the image";
"чтобы увидеть спектр ROI" = "to view ROI spectrum";
"Развернуть панель" = "Expand panel";
"Свернуть панель" = "Collapse panel";
"Имя" = "Name";
"Копировать" = "Copy";
"Редактирование ROI" = "ROI editing";
"Размер изображения недоступен" = "Image size is unavailable";
"Отмена" = "Cancel";
"Применить" = "Apply";
"Нужны данные изображения для проверки." = "Image data is required for validation.";
"x1 не может быть больше x2." = "x1 cannot be greater than x2.";
"y1 не может быть больше y2." = "y1 cannot be greater than y2.";
"Не удалось обновить ROI." = "Failed to update ROI.";
"λ (нм)" = "lambda (nm)";
"Канал" = "Channel";
"Сохранить точку" = "Save point";
"Переименовать" = "Rename";
"Удалить точку" = "Delete point";
"Метод" = "Method";
"Сохранить область" = "Save region";
"Редактировать" = "Edit";
"Удалить область" = "Delete region";
"Интенсивность" = "Intensity";
"Серия" = "Series";

"Гиперкуб" = "Hypercube";
"Маска" = "Mask";
"Параметры TIFF:" = "TIFF options:";
"Совместимость с ENVI (многоканальный TIFF)" = "ENVI compatibility (multichannel TIFF)";
"По умолчанию каждый канал экспортируется отдельным кадром TIFF." = "By default, each channel is exported as a separate TIFF frame.";
"Нет маски для экспорта" = "No mask available for export";
"Переключитесь в режим Mask и создайте маску" = "Switch to Mask mode and create a mask";
"Формат экспорта маски:" = "Mask export format:";
"Цветной PNG с цветами классов. Для визуализации." = "Color PNG with class colors for visualization.";
"Одноканальный PNG (grayscale). Значения пикселей = номера классов." = "Single-channel PNG (grayscale). Pixel values are class IDs.";
"NumPy массив HxW uint8. Значения = номера классов (0 = фон)." = "NumPy HxW uint8 array. Values are class IDs (0 = background).";
"MATLAB формат с маской и метаданными классов." = "MATLAB format with mask and class metadata.";
"Экспорт в цвете" = "Export in color";
"Имя переменной:" = "Variable name:";
"Информация о маске:" = "Mask information:";
"Размер" = "Size";
"Классов" = "Classes";
"Экспорт гиперкуба" = "Hypercube export";
"Формат экспорта:" = "Export format:";
"Экспортировать всю библиотеку" = "Export entire library";
"Библиотека пуста" = "Library is empty";
"Библиотека пуста. Добавьте файлы или выключите опцию экспорта библиотеки." = "Library is empty. Add files or disable library export.";
"NumPy формат. Сохраняет тип данных и порядок (C/Fortran). Совместим с Python/NumPy." = "NumPy format. Preserves data type and order (C/Fortran). Compatible with Python/NumPy.";
"MATLAB формат. Сохраняет тип данных. Совместим с MATLAB/Octave. Данные в column-major порядке." = "MATLAB format. Preserves data type. Compatible with MATLAB/Octave. Data is column-major.";
"Экспорт всех каналов в один многокадровый TIFF файл." = "Export all channels into a single multi-frame TIFF file.";
"Экспорт каналов как отдельные PNG изображения в выбранную папку. Все типы данных автоматически масштабируются." = "Export channels as separate PNG files into the selected folder. All data types are scaled automatically.";
"Быстрый PNG" = "Quick PNG";
"Быстрый экспорт RGB изображения с выбранным режимом цветосинтеза." = "Quick export of RGB image with selected color synthesis mode.";
"Режим цветосинтеза:" = "Color synthesis mode:";
"Для корректного цветосинтеза необходимо задать длины волн." = "Wavelengths are required for correct color synthesis.";
"Параметры MAT:" = "MAT options:";
"Имя переменной в MAT файле (например: 'data', 'cube', 'hypercube')." = "Variable name in MAT file (for example: 'data', 'cube', 'hypercube').";
"Сохранить wavelengths в MAT как переменную" = "Save wavelengths in MAT as a variable";
"Wavelengths будут сохранены как переменная '%@_wavelengths' в том же MAT файле." = "Wavelengths will be saved as variable '%@_wavelengths' in the same MAT file.";
"Wavelengths будут сохранены в отдельный .txt файл." = "Wavelengths will be saved in a separate .txt file.";
"Экспортировать длины волн" = "Export wavelengths";
"Длины волн отсутствуют. Сгенерируйте их в панели управления (Start/Step) перед экспортом." = "Wavelengths are missing. Generate them in the control panel (Start/Step) before export.";
"Информация о кубе:" = "Cube information:";
"Файлов в библиотеке" = "Files in library";
"Текущий файл" = "Current file";
"Тип данных" = "Data type";
"Порядок" = "Order";
"Память" = "Memory";
"Открой гиперкуб или включите экспорт всей библиотеки." = "Open a hypercube or enable full library export.";
"Экспорт" = "Export";
"Открой гиперкуб для экспорта" = "Open a hypercube for export";

"export.format.npy" = "NumPy (.npy)";
"export.format.mat" = "MATLAB (.mat)";
"export.format.tiff" = "TIFF (.tiff)";
"export.format.envi_dat" = "ENVI DAT + HDR";
"export.format.envi_raw" = "ENVI RAW + HDR";
"export.format.png_channels" = "PNG Channels";
"export.format.quick_png" = "Quick PNG";
"export.format.mask_png" = "Mask PNG";
"export.format.mask_npy" = "Mask NumPy";
"export.format.mask_mat" = "Mask MAT";
"export.tab.cube" = "Hypercube";
"export.tab.mask" = "Mask";

"graph.panel.title.spectrum" = "Spectrum graph";
"graph.panel.title.roi" = "ROI spectrum graph";
"graph.panel.status.no_points" = "No saved points";
"graph.panel.status.saved_points" = "Saved: %d";
"graph.panel.status.no_roi" = "No saved regions";
"graph.panel.status.roi_count" = "Regions: %d";
"graph.panel.status.no_tool" = "No tool selected";
"graph.panel.empty.click_image" = "Click on the image";
"graph.panel.empty.pixel_spectrum" = "to view pixel spectrum";
"graph.panel.empty.draw_roi" = "Draw a region on the image";
"graph.panel.empty.roi_spectrum" = "to view ROI spectrum";
"graph.panel.inactive.choose_tool" = "Choose a tool";
"graph.panel.inactive.activate_analysis" = "Enable analysis in the top dock";
"graph.panel.help.collapse" = "Collapse panel";
"graph.panel.help.expand" = "Expand panel";
"graph.roi.error.image_data_required" = "Image data is required for validation.";
"graph.roi.error.x_order" = "x1 cannot be greater than x2.";
"graph.roi.error.y_order" = "y1 cannot be greater than y2.";
"graph.roi.error.x_range" = "x must be in range 0...%d.";
"graph.roi.error.y_range" = "y must be in range 0...%d.";
"graph.roi.error.update_failed" = "Failed to update ROI.";
"graph.axis.wavelength_nm" = "lambda (nm)";
"graph.axis.channel" = "Channel";
"graph.axis.intensity" = "Intensity";
"graph.axis.series" = "Series";
"graph.pending.point" = "Selected point: %1$@: (%2$d, %3$d) - not saved";
"graph.pending.roi" = "Selected region: %1$@: (%2$d, %3$d) - (%4$d, %5$d) - not saved";
"graph.action.save_point" = "Save point";
"graph.action.save_roi" = "Save region";
"graph.action.rename" = "Rename";
"graph.action.edit" = "Edit";
"graph.action.delete_point" = "Delete point";
"graph.action.delete_roi" = "Delete region";
"graph.roi.method" = "Method";

"graph.window.dataset.points" = "Points";
"graph.window.dataset.roi" = "ROI";
"graph.window.style.lines" = "Lines";
"graph.window.style.lines_points" = "Lines + points";
"graph.window.style.area" = "Area";
"graph.window.palette.default" = "Default";
"graph.window.palette.warm" = "Warm";
"graph.window.palette.cool" = "Cool";
"graph.window.palette.mono" = "Monochrome";

"graph.window.sources" = "Sources";
"graph.window.show_all" = "Show all";
"graph.window.hide_all" = "Hide all";
"graph.window.empty.no_saved_spectra" = "No saved spectra";
"graph.window.empty.add_points_roi" = "Add points or ROI\non library images";
"graph.window.no_data" = "No data";
"graph.window.show_library" = "Show library";
"graph.window.section.data" = "Data";
"graph.window.source" = "Source";
"graph.window.section.display" = "Display";
"graph.window.line_style" = "Line style";
"graph.window.palette" = "Palette";
"graph.window.line_width" = "Line width";
"graph.window.point_size" = "Point size";
"graph.window.section.axis_x" = "X axis";
"graph.window.auto_scale" = "Auto scale";
"graph.window.min" = "Min";
"graph.window.max" = "Max";
"graph.window.section.axis_y" = "Y axis";
"graph.window.section.elements" = "Elements";
"graph.window.show_legend" = "Show legend";
"graph.window.show_grid" = "Show grid";
"graph.window.title" = "Spectrum graph";
"graph.window.header.series_count" = "%lld series from %lld source(s)";
"graph.window.export.png_large" = "Export PNG (1800x1200)";
"graph.window.export.png_small" = "Export PNG (900x600)";
"graph.window.export.pdf" = "Export PDF";
"graph.window.export.json" = "Export JSON";
"graph.window.export" = "Export";
"graph.window.empty.no_data_to_display" = "No data to display";
"graph.window.empty.save_points_or_regions" = "Save points or regions in the graph panel";
"graph.window.legend" = "Legend";
"graph.window.points_count" = "%lld points";
"graph.window.line_shape" = "Line shape";
"graph.window.thickness" = "Thickness";
"graph.window.opacity" = "Opacity";
"graph.window.show_points" = "Show points";
"graph.window.reset" = "Reset";
"graph.window.apply" = "Apply";
"graph.window.export.title" = "Export graph";
"graph.window.export.message" = "Choose a location to save %@";
"graph.window.metrics.call_metric" = "Call metric";
"graph.window.metrics.select_target_title" = "Select another legend item";
"graph.window.metrics.select_target_subtitle" = "Reference spectrum: %@";
"graph.window.metrics.sheet.title" = "Metrics";
"graph.window.metrics.sheet.compare" = "Comparing: %1$@ vs %2$@";
"graph.window.metrics.settings" = "Settings";
"graph.window.metrics.evaluation_mode" = "Calculation scope";
"graph.window.metrics.evaluation.averaged" = "Averaged spectrum";
"graph.window.metrics.evaluation.per_hyperpixel" = "Per hyperpixel (ROI)";
"graph.window.metrics.evaluation.per_hyperpixel_hint" = "Per-hyperpixel mode is available for ROI pairs from the active cube with matching width and height.";
"graph.window.metrics.metric" = "Metric";
"graph.window.metrics.metric.mse" = "MSE";
"graph.window.metrics.metric.rmse" = "RMSE";
"graph.window.metrics.metric.psnr" = "PSNR";
"graph.window.metrics.alignment" = "Alignment";
"graph.window.metrics.alignment.by_index" = "By index";
"graph.window.metrics.alignment.by_wavelength" = "By wavelength";
"graph.window.metrics.resample_points" = "Resample points";
"graph.window.metrics.psnr_peak" = "PSNR peak";
"graph.window.metrics.psnr_peak.data_range" = "Data range";
"graph.window.metrics.psnr_peak.custom" = "Custom";
"graph.window.metrics.psnr_custom_value" = "Peak value";
"graph.window.metrics.calculate" = "Calculate";
"graph.window.metrics.result" = "Result";
"graph.window.metrics.result.samples" = "Samples used: %lld";
"graph.window.metrics.result.peak" = "PSNR peak: %@";
"graph.window.metrics.result.hyperpixels" = "Hyperpixels compared: %lld";
"graph.window.metrics.result.mean" = "Mean: %@";
"graph.window.metrics.result.min" = "Min: %@";
"graph.window.metrics.result.max" = "Max: %@";
"graph.window.metrics.error.empty" = "Spectra contain no comparable values.";
"graph.window.metrics.error.need_wavelengths" = "Both spectra must have wavelength data for this mode.";
"graph.window.metrics.error.no_overlap" = "Spectra have no common wavelength range.";
"graph.window.metrics.error.invalid_peak" = "PSNR peak value must be greater than 0.";
"graph.window.metrics.error.per_pixel_requires_roi" = "Per-hyperpixel mode requires two ROI spectra.";
"graph.window.metrics.error.per_pixel_current_cube_only" = "Per-hyperpixel mode is available only for ROI spectra from the active cube.";
"graph.window.metrics.error.roi_spatial_mismatch" = "ROI sizes must match for per-hyperpixel comparison.";
"graph.window.metrics.error.roi_data_unavailable" = "ROI pixel data is unavailable for selected spectra.";
"graph.window.metrics.value.infinity" = "infinity";

"content.export.png_channels.choose_folder_message" = "Choose a folder to save PNG channels (%@_channel_XXX.png)";
"content.dimensions.2d" = "size: %lld x %lld";
"content.lambda.channels_count" = "λ: %lld channels";
"content.lambda.range_brackets" = "(%@ - %@ nm)";
"content.mask.size" = "Mask: %lld x %lld";
"content.channel.wavelength_suffix" = " (%@ nm)";
"content.channel.current" = "Channel: %lld / %lld%@";
"content.color_mapping.channel_nm" = "%@: ch %lld (%@ nm)";
"content.color_mapping.channel" = "%@: ch %lld";
"content.trim.range_nm" = "Trim: %@ - %@ nm";
"content.trim.channels_count" = "(%lld ch.)";
"content.trim.range_channel" = "Trim: channel %lld - %lld";
"content.lambda.step" = "Step: %@ nm";
"content.channels_count" = "%lld channels";
"content.lambda.range" = "%@ - %@ nm";
"content.alignment.channel" = "Channel %lld";
"content.export.log.skip_no_data" = "Skipping %1$@ - no data for export";
"content.export.log.exported" = "Exported %1$@";
"content.export.log.error" = "Export error %1$@: %2$@";
"PCA: спектры пикселей; lock basis сохраняет базис до смены параметров." = "PCA: pixel spectra; lock basis keeps the basis until parameters change.";

"assembler.title" = "HSI Assembler";
"assembler.header.materials_count" = "Materials: %lld";
"assembler.wavelength.notation.sequential" = "per line";
"assembler.wavelength.not_set" = "not set";
"assembler.wavelength.value_nm" = "%@ nm";
"assembler.error.no_materials" = "Add materials first";
"assembler.error.wavelength_file_read_failed" = "Failed to read wavelength file";
"assembler.error.wavelength_file_empty" = "Wavelength file is empty";
"assembler.error.mixed_notation" = "The file has mixed notations. Use one format for the whole file.";
"assembler.error.invalid_wavelength_value_line" = "Invalid wavelength value at line %lld";
"assembler.error.wavelength_count_mismatch" = "Wavelength count (%lld) does not match materials count (%lld)";
"assembler.error.invalid_mapping_line" = "Invalid mapping row at line %lld. Expected format: name:value";
"assembler.error.no_matching_files" = "No file names matched in wavelength file";
"assembler.error.source_no_supported_files" = "No supported files in source";
"assembler.error.source_import_failure" = "Source import error: %@";
"assembler.error.open_one_source_before_bulk" = "Open one source, configure materials, and retry bulk build";
"assembler.error.duplicate_names_in_template" = "Current materials contain duplicate file names; template bulk build is unavailable";
"assembler.validation.inconsistent_resolution" = "Material sizes differ. Convert all images to one resolution.";
"assembler.validation.non_grayscale" = "There are color materials. Double-click \"Palette\" to split them into channels.";
"assembler.dialog.choose_wavelength_file" = "Choose wavelength file";
"assembler.dialog.choose_wavelength_file_for_source" = "Choose wavelength file for '%@'";
"assembler.alert.empty_source_message" = "Folder '%@' has no PNG/JPG/BMP files. Remove this source from the list?";
"assembler.action.add" = "Add";
"assembler.action.import" = "Import";
"assembler.action.load" = "Load";
"assembler.progress.preparing" = "Preparing…";
"assembler.progress.bulk_building" = "Bulk build…";
"assembler.progress.importing" = "Importing…";
"assembler.progress.import" = "Import: %lld/%lld";
"assembler.info.sources_added" = "Sources added: %lld";
"assembler.info.opening_source" = "Opening source '%@'…";
"assembler.info.no_sources_for_bulk" = "No sources for bulk build";
"assembler.info.bulk_completed" = "Bulk build completed: success %lld, skipped %lld";
"assembler.failure.duplicate_names" = "%@: duplicate file names found";
"assembler.failure.missing_file" = "%@: missing file %@";
"assembler.failure.no_matching_txt" = "%@: no matching wavelength txt found";
"assembler.info.wavelengths_loaded_updated" = "Wavelengths loaded: %lld materials updated";
"assembler.info.no_new_files_for_import" = "No new files to import";
"assembler.info.files_added_partial" = "Added: %lld. Some files were skipped";
"assembler.info.files_added" = "Files added: %lld";
"assembler.info.applied_wavelength_file" = "Applied wavelength file: %@ (%lld)";
"assembler.info.new_hsi_added" = "New HSI added to library: %@";
"assembler.info.materials_sorted_by_wavelength" = "Materials sorted by wavelengths";
"assembler.info.material_split_channels" = "%@ was split into channels";

"export.tiff.envi_info" = "The file will be saved as one interleaved TIFF (Photometric: minisblack, PlanarConfig: contig).";
"export.tiff.default_info" = "By default, each channel is exported as a separate TIFF frame.";
"export.mask.format.png_color_info" = "Color PNG with class colors for visualization.";
"export.mask.format.png_grayscale_info" = "Single-channel PNG (grayscale). Pixel values are class IDs.";
"export.mask.format.npy_info" = "NumPy HxW uint8 array. Values are class IDs (0 = background).";
"export.mask.format.mat_info" = "MATLAB format with mask and class metadata.";
"export.library.empty_hint" = "Library is empty. Add files or disable library export.";
"export.library.will_export_files" = "%lld files will be exported. Saved processing from the library is used for each file.";
"export.format.npy_info" = "NumPy format. Preserves data type and order (C/Fortran). Compatible with Python/NumPy.";
"export.format.mat_info" = "MATLAB format. Preserves data type. Compatible with MATLAB/Octave. Data is column-major.";
"export.format.tiff_info" = "Export all channels into a single multi-frame TIFF file.";
"export.format.envi_dat_info" = "Export ENVI pair: .dat + .hdr. Configure HDR metadata and binary layout.";
"export.format.envi_raw_info" = "Export ENVI pair: .raw + .hdr. Configure HDR metadata and binary layout.";
"export.format.png_channels_info" = "Export channels as separate PNG files into the selected folder. All data types are scaled automatically.";
"export.format.quick_png_info" = "Quick export of RGB image with selected color synthesis mode.";
"export.color_synthesis.needs_wavelengths" = "Wavelengths are required for correct color synthesis.";
"export.mat.variable_name_info" = "Variable name in MAT file (for example: 'data', 'cube', 'hypercube').";
"export.mat.wavelengths_as_variable_info" = "Wavelengths will be saved as variable '%@_wavelengths' in the same MAT file.";
"export.mat.wavelengths_separate_txt_info" = "Wavelengths will be saved in a separate .txt file.";
"export.wavelengths.extra_file_per_line" = "An additional '_wavelengths.txt' file with %lld wavelengths will be created (one value per line).";
"export.wavelengths.extra_file" = "An additional '_wavelengths.txt' file with %lld wavelengths will be created.";
"export.wavelengths.base_file" = "A '%@_wavelengths.txt' file with %lld wavelengths will be created.";
"export.wavelengths.envi_hdr" = "Wavelengths will be written to the 'wavelength' field in the .hdr file.";
"export.wavelengths.missing_hint" = "Wavelengths are missing. Generate them in the control panel (Start/Step) before export.";
"export.cube.open_or_enable_library" = "Open a hypercube or enable full library export.";
"export.error.library_empty" = "Library is empty";
"export.error.open_cube" = "Open a hypercube for export";
"export.error.no_mask" = "No mask available for export";

"export.envi.options.title" = "ENVI HDR options";
"export.envi.binary_type.dat" = ".dat (ENVI data)";
"export.envi.binary_type.raw" = ".raw (sensor RAW style)";
"export.envi.interleave" = "Interleave";
"export.envi.data_type" = "Data type";
"export.envi.byte_order" = "Byte order";
"export.envi.byte_order.little" = "Little endian (0)";
"export.envi.byte_order.big" = "Big endian (1)";
"export.envi.file_type" = "File type";
"export.envi.sensor_type" = "Sensor type";
"export.envi.description" = "Description";
"export.envi.default_bands.include" = "Write default bands (RGB)";
"export.envi.default_bands.mode.color_synthesis" = "From current color synthesis";
"export.envi.default_bands.mode.specim" = "SPECIM preset (70/53/19)";
"export.envi.default_bands.mode.custom" = "Custom";
"export.envi.acquisition_date.include" = "Write acquisition date";
"export.envi.coordinates.include" = "Write latitude/longitude";
"export.envi.georef.include" = "Write geo-referencing (map info)";
"export.envi.georef.info" = "If geo-referencing exists in the cube, 'map info', 'x start', and 'y start' will be written to .hdr.";
"export.envi.latitude" = "Latitude";
"export.envi.longitude" = "Longitude";
"export.envi.wavelength_units" = "Wavelength units";
"export.envi.additional_fields" = "Additional HDR fields";
"export.envi.additional_fields.hint" = "One field per line: key = value. Reserved keys are ignored.";
"export.envi.options.info" = "Required ENVI fields are generated automatically. Optional fields help preserve sensor metadata.";
"export.envi.error.invalid_layout" = "Failed to resolve cube layout for ENVI export";
"export.envi.error.failed_to_create_file" = "Failed to create file: %@";
"export.envi.error.invalid_additional_field_line" = "Invalid additional HDR field at line %d";

"mask.brush_size_px" = "Brush size: %lld px";
"graph.roi.image_size_px" = "Image size: %lld x %lld px";
"Включить рисование" = "Enable drawing";
"Отключить рисование" = "Disable drawing";
"Добавить слой маски" = "Add mask layer";
"Слои" = "Layers";
"Инструменты" = "Tools";
"Действия" = "Actions";
"Подсказки" = "Hints";
"Заблокировать" = "Lock";
"Разблокировать" = "Unlock";
"Переместить вверх" = "Move up";
"Переместить вниз" = "Move down";
"Прозрачность:" = "Opacity:";
"Отменить (⌘Z)" = "Undo (⌘Z)";
"↑↓ для изменения порядка слоёв" = "Use ↑↓ to change layer order";
"• Shift — показать только активный слой" = "• Shift - show only active layer";
"• ⌘Z — отмена последнего действия" = "• ⌘Z - undo last action";
"• File → Экспорт для сохранения маски" = "• File -> Export to save mask";
"Нет данных" = "No data";
"Пайплайн обработки" = "Processing pipeline";
"Пайплайн пуст" = "Pipeline is empty";
"Нормализация, клиппинг, типы" = "Normalization, clipping, data types";
"Поворот, транспонирование, размер, обрезка" = "Rotation, transpose, size, crop";
"Калибровка и спектральные операции" = "Calibration and spectral operations";
"Добавить обработку…" = "Add operation…";
"Вставить" = "Paste";
"Автоматическое применение" = "Automatic apply";
"Ручной" = "Manual";
"Геометрия" = "Geometry";
"Спектр" = "Spectrum";
"Значения" = "Values";
"Каналы" = "Channels";
"Длины волн" = "Wavelengths";
"Ручной ввод" = "Manual input";
"Из txt" = "From txt";
"Настройка: %@" = "Setting: %@";
"Тип нормализации:" = "Normalization type:";
"Диапазон:" = "Range:";
"Исходный диапазон:" = "Source range:";
"Новый диапазон:" = "New range:";
"Процентили:" = "Percentiles:";
"Точность вычислений:" = "Computation precision:";
"Сохранить тип данных" = "Preserve data type";
"При выборе Float32 результат всегда будет Float32, независимо от исходного типа" = "With Float32 selected, result is always Float32 regardless of source type";
"При нормализации тип данных будет сохранён, если диапазон позволяет (например, UInt8 для [0, 255])" = "During normalization, source data type is preserved if range allows it (e.g. UInt8 for [0, 255])";
"Результат нормализации всегда будет Float64" = "Normalization result will always be Float64";
"Размер:" = "Size:";
"Ширина" = "Width";
"Высота" = "Height";
"Соотношение" = "Aspect ratio";
"Фиксировать соотношение сторон" = "Lock aspect ratio";
"Будет сохранено соотношение: %.3f" = "Aspect ratio to preserve: %.3f";
"Алгоритм интерполяции:" = "Interpolation algorithm:";
"Параметр a (Catmull-Rom = -0.5):" = "Parameter a (Catmull-Rom = -0.5):";
"Число лепестков (a):" = "Lobes count (a):";
"Точность вычислений" = "Computation precision";
"Каждый канал будет ресайзнут отдельно в выбранном алгоритме." = "Each channel will be resized separately using selected algorithm.";
"Спектральная интерполяция" = "Spectral interpolation";
"Длины волн не заданы — интерполяция невозможна" = "Wavelengths are not set - interpolation is unavailable";
"Целевая сетка" = "Target grid";
"Целевое число каналов" = "Target channel count";
"Диапазон λ" = "Lambda range";
"Загрузить λ из txt…" = "Load lambda from txt…";
"Из файла: %d каналов, %.2f – %.2f нм" = "From file: %d channels, %.2f - %.2f nm";
"Экстраполяция может давать нефизические значения за пределами диапазона." = "Extrapolation may produce non-physical values out of range.";
"Обрезка спектра" = "Spectral trimming";
"Диапазон каналов: 0–%d (%d всего)" = "Channel range: 0-%d (%d total)";
"Длины волн недоступны" = "Wavelengths unavailable";
"Останется: %d каналов" = "Will remain: %d channels";
"Ввод" = "Input";
"Начальный канал" = "Start channel";
"Конечный канал" = "End channel";
"Начальная λ" = "Start lambda";
"Конечная λ" = "End lambda";
"нм" = "nm";
"Автоматическое масштабирование" = "Automatic scaling";
"Данные будут масштабированы в диапазон целевого типа" = "Data will be scaled to target type range";
"Значения будут обрезаны (clamped)" = "Values will be clamped";
"Ограничение значений (clipping):" = "Value clipping:";
"Нижний порог" = "Lower threshold";
"Верхний порог" = "Upper threshold";
"Верхний порог меньше нижнего — значения будут поменяны местами при применении." = "Upper threshold is lower than lower threshold; values will be swapped on apply.";
"Угол поворота:" = "Rotation angle:";
"Поворот выполняется по часовой стрелке относительно центра изображения" = "Rotation is clockwise around image center";
"Порядок осей HWC:" = "Axis order HWC:";
"Например: HWC, CHW, WCH" = "For example: HWC, CHW, WCH";
"Порядок не изменится (no-op)." = "Order will not change (no-op).";
"После применения отображаемый layout переключится на %@." = "After apply, displayed layout will switch to %@.";
"Некорректный порядок. Используйте ровно 3 символа H/W/C без повторов (например HWC)." = "Invalid order. Use exactly 3 symbols H/W/C without repeats (e.g. HWC).";
"Выбор области обрезки:" = "Crop area selection:";
"Размер области" = "Area size";
"Границы (px)" = "Bounds (px)";
"Левая граница" = "Left bound";
"Правая граница" = "Right bound";
"Верхняя граница" = "Top bound";
"Нижняя граница" = "Bottom bound";
"Предпросмотр недоступен" = "Preview unavailable";
"Автоподбор обрезки по ГСИ-референсу" = "Auto-crop by HSI reference";
"ГСИ-референс из библиотеки" = "HSI reference from library";
"Не выбран" = "Not selected";
"Целевая метрика" = "Target metric";
"Каналы source/ref (через запятую)" = "Source/ref channels (comma separated)";
"Должно быть одинаковое количество каналов, минимум 1." = "Channel counts must match, minimum 1.";
"Ограничить ширину" = "Limit width";
"Ограничить высоту" = "Limit height";
"Оптимизация перебора" = "Search optimization";
"Шаг позиции" = "Position step";
"Шаг размера" = "Size step";
"Грубый поиск + уточнение (coarse-to-fine)" = "Coarse search + refinement (coarse-to-fine)";
"Оставлять уточняющий резерв" = "Keep refinement margin";
"Раннее отсечение кандидатов (MSE)" = "Early candidate pruning (MSE)";
"Сохранять соотношение сторон референса" = "Save reference aspect ratio";
"Допустимое отклонение соотношения сторон (%)" = "Allowed aspect ratio deviation (%)";
"Downsample для метрики" = "Downsample for metric";
"Быстро" = "Fast";
"Баланс" = "Balanced";
"Точно" = "Accurate";
"Оценка вариантов: ~%d (зависит от ограничений и шага)" = "Candidate estimate: ~%d (depends on limits and step)";
"Для ускорения увеличьте шаги, включите coarse-to-fine и используйте downsample 2x/4x." = "To speed up, increase steps, enable coarse-to-fine, and use 2x/4x downsample.";
"Подбор..." = "Searching...";
"Подобрать обрезку" = "Auto-crop";
"Вычисление..." = "Computing...";
"Лучший результат: %@=%@, окно %dx%d, проверено %d" = "Best result: %@=%@, window %dx%d, evaluated %d";
"Калибровка изображения" = "Image calibration";
"Выберите спектры или REF файлы для белой и/или чёрной точки калибровки." = "Select spectra or REF files for white and/or black calibration points.";
"Белая точка (эталон белого)" = "White point (white reference)";
"Выбрать белую точку" = "Select white point";
"Выбрать файл REF" = "Select REF file";
"Чёрная точка (эталон чёрного)" = "Black point (black reference)";
"Выбрать чёрную точку" = "Select black point";
"Убрать" = "Remove";
"Направление сканирования:" = "Scan direction:";
"Использовать параметры сканирования" = "Use scan parameters";
"REF файлы обнаружены — возможно, стоит включить параметры сканирования." = "REF files detected - consider enabling scan parameters.";
"Целевой диапазон:" = "Target range:";
"Ограничивать в диапазоне" = "Clamp to range";
"Выберите хотя бы одну точку или REF для калибровки" = "Select at least one point or REF for calibration";
"Нет сохранённых спектров" = "No saved spectra";
"Точки" = "Points";
"Области ROI" = "ROI regions";
"Выберите REF файл (HDR/RAW)" = "Select REF file (HDR/RAW)";
"Выберите txt файл со списком длин волн (по одному значению на строку)" = "Select txt file with wavelength list (one value per line)";
"Загрузить" = "Load";
"Не удалось прочитать txt файл длин волн" = "Failed to read wavelength txt file";
"Файл длин волн пуст" = "Wavelength file is empty";
"Некорректная длина волны в строке %d" = "Invalid wavelength value at line %d";
"Откройте куб перед экспортом/импортом гомографий" = "Open a cube before homography export/import";
"Нет рассчитанных гомографий для экспорта" = "No calculated homographies to export";
"Не удалось прочитать файл гомографий" = "Failed to read homography file";
"Не удалось сохранить файл гомографий" = "Failed to save homography file";
"Некорректный формат файла гомографий" = "Invalid homography file format";
"Неподдерживаемая версия файла: %@" = "Unsupported file version: %@";
"Неизвестный layout в файле: %@" = "Unknown layout in file: %@";
"Неизвестный метод оптимизации: %@" = "Unknown optimization method: %@";
"Неизвестная метрика: %@" = "Unknown metric: %@";
"Эталонный канал %d вне диапазона 0...%d" = "Reference channel %d is out of range 0...%d";
"Некорректные опорные точки в файле" = "Invalid anchor points in file";
"Некорректная матрица гомографии для канала %d" = "Invalid homography matrix for channel %d";
"Layout не совпадает: в файле %@, в текущем кубе %@" = "Layout mismatch: file %@, current cube %@";
"Пространственные характеристики не совпадают: файл %@, текущий куб %@" = "Spatial properties mismatch: file %@, current cube %@";
"Число каналов не совпадает: файл %d, текущий куб %d" = "Channel count mismatch: file %d, current cube %d";
"В файле есть длины волн, но в текущем кубе они не заданы" = "File contains wavelengths, but current cube has none";
"Число длин волн не совпадает: файл %d, текущий куб %d" = "Wavelength count mismatch: file %d, current cube %d";
"Спектральные характеристики отличаются (канал %d)" = "Spectral properties differ (channel %d)";
"Сводка результата в файле повреждена" = "Result summary in file is corrupted";
"Сохранить рассчитанные параметры спектрального выравнивания" = "Save calculated spectral alignment parameters";
"Сохранить" = "Save";
"Гомографии сохранены: %@" = "Homographies saved: %@";
"Выберите txt файл с рассчитанными гомографиями" = "Select txt file with calculated homographies";
"Гомографии загружены из %@" = "Homographies loaded from %@";
"Включите автоподбор обрезки" = "Enable auto-crop";
"Откройте ГСИ перед автоподбором" = "Open HSI before auto-crop";
"Выберите ГСИ-референс из библиотеки" = "Select HSI reference from library";
"Укажите хотя бы один канал source и reference" = "Specify at least one source and one reference channel";
"Количество каналов source и reference должно совпадать" = "Source and reference channel counts must match";
"Каналы source вне допустимого диапазона 0...%d" = "Source channels are out of valid range 0...%d";
"Загрузка ГСИ-референса..." = "Loading HSI reference...";
"Не удалось загрузить ГСИ-референс" = "Failed to load HSI reference";
"Каналы reference вне диапазона 0...%d" = "Reference channels are out of range 0...%d";
"Автоподбор не нашёл корректную область. Проверьте ограничения и каналы." = "Auto-crop did not find a valid area. Check limits and channels.";
"Готово" = "Done";
"Найдена область: %dx%d, %@=%@, проверено %d" = "Area found: %dx%d, %@=%@, evaluated %d";
"Применить изменения" = "Apply changes";
"Закрыть" = "Close";
"Нет предпросмотра" = "No preview";
"Результаты выравнивания" = "Alignment results";
"Метрика" = "Metric";
"Среднее значение" = "Average value";
"Эталонный канал" = "Reference channel";
"pipeline.setting.current" = "Setting: %@";
"pipeline.alignment.estimated_time" = "Estimated time: %@";
"pipeline.alignment.channel_progress" = "Channel %lld/%lld";
"pipeline.alignment.elapsed" = "Elapsed: %@";
"pipeline.alignment.remaining" = "Remaining: %@";
"pipeline.alignment.cache_mismatch" = "Cache has %lld homographies, image has %lld channels. Recalculation will be performed on apply.";
"pipeline.trim.channel_range_total" = "Channel range: 0-%lld (%lld total)";
"pipeline.trim.lambda_range" = "Lambda range: %@ - %@ nm";
"pipeline.trim.remaining_channels" = "Will remain: %lld channels";
"pipeline.trim.current_channels" = "Current trim: channels %lld - %lld";
"pipeline.trim.will_clip_to_lambda" = "Will be clipped to lambda %@ - %@ nm";
"pipeline.trim.nearest_channels" = "Nearest channels: %lld - %lld (lambda %@ - %@ nm)";
"pipeline.transpose.source_layout" = "Source: %@";
"pipeline.transpose.result_layout" = "Result: %@";
"pipeline.transpose.after_apply_layout" = "After apply, displayed layout will switch to %@.";
"pipeline.transpose.normalized_input" = "Normalized input: %@";
"pipeline.spectral_interp.loaded_wavelengths" = "Loaded %lld wavelengths from %@";
"pipeline.spectral_interp.source_range" = "Source range: %.2f - %.2f nm";
"pipeline.spectral_interp.invalid_wavelength_line" = "Invalid wavelength value at line %d";
"pipeline.alignment.homographies_saved" = "Homographies saved: %@";
"pipeline.alignment.homographies_loaded" = "Homographies loaded from %@";
"pipeline.crop.size_px" = "%1$d x %2$d px";
"pipeline.calibration.ref_dimensions" = "REF %1$dx%2$d";
"pipeline.resize.aspect_ratio_preserved" = "Aspect ratio to preserve: %.3f";
"pipeline.spectral_interp.file_channels_range" = "From file: %1$d channels, %2$.2f - %3$.2f nm";
"Результаты по каналам" = "Per-channel results";

"В источнике нет поддерживаемых файлов" = "No supported files in source";
"В папке '%@' нет PNG/JPG/BMP файлов. Удалить этот источник из списка?" = "Folder '%@' has no PNG/JPG/BMP files. Remove this source from the list?";
"Выберите материал" = "Select material";
"Выберите стратегию сборки для остальных источников." = "Choose build strategy for remaining sources.";
"Двойной клик по источнику открывает его содержимое в «Материалах»." = "Double-click a source to open its contents in \"Materials\".";
"Длина волны (нм) заполняется опционально для каждого материала." = "Wavelength (nm) is optional for each material.";
"Длина волны" = "Wavelength";
"Длина волны, нм" = "Wavelength, nm";
"Добавьте директории с материалами." = "Add directories with materials.";
"Загрузить λ…" = "Load lambda…";
"Импортировать…" = "Import…";
"Использовать txt каждого источника" = "Use txt from each source";
"Использовать настройки текущих материалов" = "Use current materials settings";
"Источники" = "Sources";
"Массовая сборка" = "Bulk build";
"Материалы" = "Materials";
"Оставить" = "Keep";
"Открыть" = "Open";
"Перетащите PNG, JPG или BMP сюда" = "Drop PNG, JPG, or BMP here";
"Порядок строк соответствует порядку каналов при сборке." = "Row order matches channel order during assembly.";
"Предпросмотр" = "Preview";
"Разрешение" = "Resolution";
"Сборка" = "Assemble";
"Сортировать λ" = "Sort lambda";
"Тип" = "Type";
"Убрать источник" = "Remove source";
"Удалить" = "Delete";
"Файл" = "File";
"или нажмите «Импортировать…»" = "or click \"Import…\"";
"например 550" = "e.g. 550";
"Цветосинтез:" = "Color synthesis:";
"Применить обрезку" = "Apply trim";
"Отменить" = "Cancel";
"Обрезать каналы" = "Trim channels";
"Пропуск %@ — нет данных для экспорта" = "Skipping %@ - no data for export";
"Экспортирован %@" = "Exported %@";
"Ошибка экспорта %@: %@" = "Export error %@: %@";

"Добавьте хотя бы один материал" = "Add at least one material";
"Дождитесь завершения текущей операции" = "Wait for the current operation to finish";
"Куб" = "Cube";
"Импорт гиперкуба…" = "Importing hypercube…";
"Выберите ROI для PCA" = "Select ROI for PCA";
"Подготовка…" = "Preparing…";
"Нет данных для оценки WDVI" = "No data available for WDVI estimation";
"Не удалось определить layout" = "Failed to determine layout";
"Не удалось определить каналы Red/NIR" = "Failed to determine Red/NIR channels";
"Выберите хотя бы один ROI для оценки" = "Select at least one ROI for estimation";
"Оценка линии почвы…" = "Estimating soil line…";
"Размеры изображения некорректны" = "Image dimensions are invalid";
"Нет данных в выбранных ROI" = "No data in selected ROI";
"Недостаточно данных после фильтрации" = "Insufficient data after filtering";
"Сначала открой гиперкуб" = "Open a hypercube first";
"Не удалось определить число каналов" = "Failed to determine channel count";
"Некорректные параметры λ (от/до)" = "Invalid lambda parameters (from/to)";
"Значение 'до' должно быть больше 'от'" = "The 'to' value must be greater than 'from'";
"Вычисление выравнивания…" = "Computing alignment…";
"Применение последней операции…" = "Applying last operation…";
"Применение пайплайна…" = "Applying pipeline…";
"Некорректный диапазон обрезки" = "Invalid trim range";
"MAT файл не содержит подходящих 3D переменных" = "MAT file does not contain suitable 3D variables";
"Выбор переменной отменён" = "Variable selection was cancelled";
"Для выбранного куба не заданы длины волн" = "Wavelengths are not set for the selected cube";
"Сначала задайте длины волн для текущего куба" = "Set wavelengths for the current cube first";
"Не удалось получить доступ к рабочей папке" = "Failed to access the workspace folder";
"Создание нового ГСИ…" = "Creating new HSI…";
"Сборка ГСИ…" = "Building HSI…";
"Экспорт библиотеки…" = "Exporting library…";
"Восстановление настроек…" = "Restoring settings…";
"Среднее" = "Mean";
"Медиана" = "Median";
"OLS (линейная регрессия)" = "OLS (linear regression)";
"Huber (робастная)" = "Huber (robust)";
"Выравнивает все каналы относительно эталонного канала, оптимизируя целевую метрику." = "Aligns all channels to a reference channel by optimizing the target metric.";
"Вычисление…" = "Computing…";
"Вычислено" = "Computed";
"Вычислить выравнивание" = "Compute alignment";
"Диапазон смещений" = "Shift range";
"Дополнительные опции" = "Additional options";
"За пределами" = "Out of range";
"Завершено" = "Completed";
"Загрузить гомографии из txt…" = "Load homographies from txt…";
"Извлечение канала" = "Extracting channel";
"Извлечение референса" = "Extracting reference";
"Инициализация" = "Initialization";
"Итерации оптимизации" = "Optimization iterations";
"Канал обработан" = "Channel processed";
"Кэшированные гомографии готовы к применению" = "Cached homographies are ready to apply";
"Метод оптимизации" = "Optimization method";
"Многомасштабный поиск" = "Multi-scale search";
"Не вычислено" = "Not computed";
"Несовпадение числа каналов" = "Channel count mismatch";
"Нет данных о результатах" = "No result data";
"Перетащите точки на изображении для настройки области выравнивания" = "Drag points on the image to adjust alignment area";
"По умолчанию" = "Default";
"Повышает точность" = "Improves accuracy";
"Подробнее" = "Details";
"Поиск гомографии" = "Homography search";
"Показать точки на изображении" = "Show points on image";
"При копировании обработки в другое изображение будут применены сохранённые параметры гомографии без пересчёта." = "When copying processing to another image, saved homography parameters are applied without recalculation.";
"Применение преобразования" = "Applying transform";
"Спектральное выравнивание" = "Spectral alignment";
"Субпиксельное уточнение" = "Subpixel refinement";
"Ускоряет вычисление" = "Speeds up computation";
"Файл не загружен. Интерполяция будет использовать ручные параметры как fallback." = "No file loaded. Interpolation will use manual parameters as fallback.";
"Файл содержит layout, пространственные/спектральные характеристики и матрицы гомографии для быстрого повторного применения." = "The file contains layout, spatial/spectral properties, and homography matrices for fast reuse.";
"Целевой тип данных:" = "Target data type:";
"Шаг поиска" = "Search step";
"Шаг" = "Step";
"Экспорт гомографий в txt…" = "Export homographies to txt…";
"Редактировать точки" = "Edit points";
"Сбросить" = "Reset";
"Укажите длину волны либо для всех материалов, либо не указывайте вовсе" = "Specify wavelength either for all materials or for none";

"app.assembly.error.inconsistent_resolution" = "Resolution %1$@ (%2$@) does not match expected %3$@";
"app.assembly.error.non_grayscale_material" = "Material %1$@ is not Grayscale. Split it into channels.";
"app.assembly.error.invalid_wavelength_at_index" = "Invalid wavelength at material #%d";
"app.assembly.error.invalid_material_data" = "Corrupted material data: %@";
"app.time.seconds" = "%d sec";
"app.time.minutes_seconds" = "%d min %d sec";
"app.time.hours_minutes" = "%d h %d min";
"app.wdvi.estimation_result" = "WDVI estimation: a=%1$@, b=%2$@ from %3$d pixels";
"app.spectrum.copy_failed_for_entry" = "Failed to copy points/areas from %@";
"app.wavelength.read_error" = "Wavelength read error: %@";
"app.wavelength.paste_count_mismatch_for_entry" = "Failed to paste wavelengths into %@: channel count mismatch";
"app.wavelength.not_applied_entries" = "Wavelengths not applied: %@";

"pipeline.alignment.reference_lambda" = "lambda = %.1f nm";
"pipeline.alignment.average_metric" = "Avg. %1$@: %2$@";
"pipeline.alignment.apply_cached_for_channels" = "Applying to an image with %d channels will use cached parameters without recalculation.";
"pipeline.auto_crop.candidate_estimate" = "Candidate estimate: ~%d (depends on limits and step)";
"pipeline.auto_crop.best_result" = "Best result: %1$@=%2$@, window %3$dx%4$d, evaluated %5$d";
"pipeline.calibration.white_ref_scan_size_mismatch" = "White REF does not match scan size (%d px).";
"pipeline.calibration.black_ref_scan_size_mismatch" = "Black REF does not match scan size (%d px).";
"pipeline.auto_crop.source_channels_out_of_range" = "Source channels are out of valid range 0...%d";
"pipeline.auto_crop.reference_channels_out_of_range" = "Reference channels are out of range 0...%d";
"pipeline.auto_crop.area_found" = "Area found: %1$dx%2$d, %3$@=%4$@, evaluated %5$d";
"pipeline.alignment.error.unsupported_version" = "Unsupported file version: %d";
"pipeline.alignment.error.invalid_layout" = "Unknown layout in file: %@";
"pipeline.alignment.error.invalid_method" = "Unknown optimization method: %@";
"pipeline.alignment.error.invalid_metric" = "Unknown metric: %@";
"pipeline.alignment.error.invalid_reference_channel" = "Reference channel %d is out of range 0...%d";
"pipeline.alignment.error.invalid_homography" = "Invalid homography matrix for channel %d";
"pipeline.alignment.error.layout_mismatch" = "Layout mismatch: file %1$@, current cube %2$@";
"pipeline.alignment.error.spatial_mismatch" = "Spatial properties mismatch: file %1$@, current cube %2$@";
"pipeline.alignment.error.channels_mismatch" = "Channel count mismatch: file %1$d, current cube %2$d";
"pipeline.alignment.error.wavelength_count_mismatch" = "Wavelength count mismatch: file %1$d, current cube %2$d";
"pipeline.alignment.error.wavelength_mismatch" = "Spectral properties differ (channel %d)";
"pipeline.alignment.reference_channel_with_lambda" = "%1$d (lambda=%2$.1f nm)";
"pipeline.time.about_seconds" = "~%d sec";
"pipeline.time.about_minutes_seconds" = "~%d min %d sec";
"pipeline.time.about_hours_minutes" = "~%d h %d min";
"pipeline.operation.display.rotation" = "Rotation %1$@";
"pipeline.operation.display.transpose_to" = "Transpose to %1$@";
"pipeline.operation.display.resize_to" = "Resize to %1$dx%2$d (%3$@)";
"pipeline.operation.details.invalid_order" = "Order: %1$@ (invalid)";
"pipeline.operation.details.resize_to" = "To %1$dx%2$d, %3$@";
"pipeline.operation.details.auto_metric" = " • auto %1$@: %2$@";
"pipeline.operation.details.channels_range_count" = "channels %1$d-%2$d (%3$d)";
"pipeline.operation.details.spectral_interp_file_channels" = "%1$d channels (txt), %2$@";
"pipeline.operation.details.spectral_interp_channels" = "%1$d channels, %2$@";
"pipeline.operation.details.spectral_alignment_status" = "%1$@ channel %2$d, %3$@";
"pipeline.calibration.ref_channels_mismatch" = "REF does not match channel count (%d)";
"pipeline.sample.point_name" = "Point (%1$d, %2$d)";
"pipeline.alignment.progress.extract_reference_channel" = "Extracting reference channel %d…";
"pipeline.alignment.progress.channel_extract_data" = "Channel %1$d/%2$d: extracting data";
"pipeline.alignment.progress.channel_search_homography" = "Channel %1$d/%2$d: searching homography";
"pipeline.alignment.progress.channel_metric_score" = "Channel %1$d/%2$d: %3$@ = %4$@";
"pipeline.alignment.progress.apply_homographies_to_channels" = "Applying homographies to %d channels…";
"pipeline.alignment.progress.completed_average" = "Completed! Average %1$@: %2$@";
"pipeline.auto_crop.progress.iteration" = "Crop search: %1$@=%2$@";

"loader.envi.hdr_not_found" = ".hdr file not found: %@";
"loader.envi.binary_not_found_expected" = "Binary file not found. Expected: %@";
"loader.envi.binary_read_failed" = "Failed to read binary file: %@";
"export.error.write_with_message" = "Write error: %@";
"export.mat.error.failed_with_message" = "MAT export error: %@";
"export.mat.error.write_wavelength_file" = "Failed to write wavelength file: %@";
"image_load.error.unsupported_format" = "Unsupported format: %@";
"image_load.error.read_details" = "Read error: %@";
"mask.import.busy" = "Importing mask…";
"mask.import.error.no_cube" = "Open an HSI cube before importing a mask.";
"mask.import.error.spatial_size_unavailable" = "Unable to determine the spatial size of the current image.";
"mask.import.error.unsupported_format" = "Unsupported mask format: %@";
"mask.import.error.read_details" = "Mask import error: %@";
"mask.import.error.size_mismatch" = "Mask size %1$@ does not match image size %2$lldx%3$lld.";
"mask.import.error.invalid_class_value" = "Invalid class value: %@. Only integer values in the range 0...255 are supported.";
"mask.import.error.png_read" = "Failed to read PNG mask.";
"mask.import.error.npy_read" = "Failed to read NumPy mask.";
"mask.import.error.mat.list_failed" = "Failed to read variables from MAT file.";
"mask.import.error.mat.no_matching_2d" = "MAT file does not contain a 2D mask of size %1$lldx%2$lld.";
"mask.import.error.mat.variable_load_failed" = "Failed to load MAT variable: %@";
"mask.import.error.mat.unsupported_type" = "Unsupported MAT data type for mask import.";
"mask.class_name_numbered" = "Class %d";

"menu.import_mask_metadata" = "Import Mask Metadata…";
"export.mask.metadata.toggle" = "Export metadata";
"export.mask.metadata.sidecar_info" = "Class metadata will be saved as a sidecar JSON file next to the exported mask.";
"export.mask.metadata.mat.prefix" = "Metadata key prefix:";
"export.mask.metadata.mat.keys_info" = "MAT metadata keys: %1$@, %2$@, %3$@, %4$@.";
"mask.metadata.import.busy" = "Importing mask metadata…";
"mask.metadata.import.error.unsupported_format" = "Unsupported metadata format: %@";
"mask.metadata.import.error.read_details" = "Metadata import error: %@";
"mask.metadata.import.error.invalid_json" = "Unable to parse metadata JSON.";
"mask.metadata.import.error.no_classes" = "No class metadata found in the file.";
"mask.metadata.import.error.invalid_class_value" = "Invalid class metadata value: %@.";
"mask.metadata.import.error.mat.list_failed" = "Failed to read variables from MAT metadata file.";
"mask.metadata.import.error.mat.not_found" = "No mask class metadata was found in the MAT file.";

"ENVI формат требует доступ к директории с парными файлами" = "ENVI format requires access to the directory with paired files";
"NDSI (снег)" = "NDSI (snow)";
"NDVI (растительность)" = "NDVI (vegetation)";
"R=630нм, G=530нм, B=450нм" = "R=630nm, G=530nm, B=450nm";
"REF должен быть 2D (B×W) с третьей размерностью = 1" = "REF must be 2D (BxW) with third dimension = 1";
"REF должен быть 2D (B×W). Проверьте размеры файла." = "REF must be 2D (BxW). Check file dimensions.";
"REF имеет пустую ширину" = "REF has zero width";
"RGB синтез" = "RGB synthesis";
"WDVI (почвенная линия)" = "WDVI (soil line)";
"Автоподбор завершён" = "Auto-crop completed";
"Без нормализации" = "No normalization";
"Без предобработки" = "No preprocessing";
"Бикубическая" = "Bicubic";
"Билинейная" = "Bilinear";
"Бинарная" = "Binary";
"Введите порядок HWC" = "Enter HWC order";
"Выберите папку для служебных файлов HSIView. Внутри будет создана папка HSIView." = "Choose a folder for HSIView service files. HSIView folder will be created inside.";
"Выбрать" = "Choose";
"Выровнять каналы по эталонному каналу" = "Align channels to reference channel";
"Гибридный" = "Hybrid";
"Градации серого" = "Grayscale";
"Диапазон (ручной)" = "Range (manual)";
"Диапазон" = "Range";
"Дифф. эволюция" = "Differential evolution";
"Заливка" = "Fill";
"Изменение размера" = "Resize";
"Изменить размер пространственных измерений" = "Resize spatial dimensions";
"Изменить спектральное разрешение по длинам волн" = "Change spectral resolution by wavelengths";
"Изменить тип данных" = "Change data type";
"Интерполяция спектра" = "Spectral interpolation";
"Информативная псевдо-цветность через PCA" = "Informative pseudo-color via PCA";
"Используем сохранённый базис…" = "Using saved basis…";
"Исходные данные без преобразований" = "Original data without transformations";
"Калибровка по белой и/или чёрной точке" = "Calibration by white and/or black point";
"Калибровка" = "Calibration";
"Квадратный корень: sqrt(x)" = "Square root: sqrt(x)";
"Кисть" = "Brush";
"Класс 1" = "Class 1";
"Классическая" = "Classic";
"Клиппинг" = "Clipping";
"Координатный спуск" = "Coordinate descent";
"Ланцош" = "Lanczos";
"Ластик" = "Eraser";
"Линейная нормализация в диапазон [0, 1]" = "Linear normalization to range [0, 1]";
"Линейная нормализация в заданный диапазон [min, max]" = "Linear normalization to custom range [min, max]";
"Линейное преобразование из указанного диапазона в новый диапазон" = "Linear transform from source range to target range";
"Логарифмическая: log(x + 1)" = "Logarithmic: log(x + 1)";
"Настройте границы" = "Configure bounds";
"Настройте диапазон" = "Configure range";
"Настройте параметры" = "Configure parameters";
"Не настроено" = "Not configured";
"Не удалось выделить память для экспорта." = "Failed to allocate memory for export.";
"Не удалось записать MAT файл" = "Failed to write MAT file";
"Не удалось записать TIFF (ENVI)" = "Failed to write TIFF (ENVI)";
"Не удалось записать TIFF" = "Failed to write TIFF";
"Не удалось записать wavelengths в MAT файл" = "Failed to write wavelengths into MAT file";
"Не удалось извлечь пиксели изображения" = "Failed to extract image pixels";
"Не удалось конвертировать в PNG" = "Failed to convert to PNG";
"Не удалось открыть .mat файл" = "Failed to open .mat file";
"Не удалось открыть TIFF файл" = "Failed to open TIFF file";
"Не удалось прочитать .hdr файл" = "Failed to read .hdr file";
"Не удалось прочитать изображение" = "Failed to read image";
"Не удалось прочитать список переменных" = "Failed to read variable list";
"Не удалось разбить изображение на каналы" = "Failed to split image into channels";
"Не удалось распарсить длины волн" = "Failed to parse wavelengths";
"Не удалось создать PNG данные" = "Failed to create PNG data";
"Не удалось создать PNG" = "Failed to create PNG";
"Не удалось создать TIFF" = "Failed to create TIFF";
"Не удалось создать изображение" = "Failed to create image";
"Неизвестное число каналов" = "Unknown number of channels";
"Некорректное разрешение изображения" = "Invalid image resolution";
"Некорректные данные для экспорта" = "Invalid data for export";
"Некорректные размеры" = "Invalid dimensions";
"Неподдерживаемый тип данных для экспорта в MAT." = "Unsupported data type for MAT export.";
"Неподдерживаемый тип данных для экспорта" = "Unsupported data type for export";
"Нет доступа к директории с ENVI файлами" = "No access to directory with ENVI files";
"Нормализация" = "Normalization";
"Обрезать изображение по пространственным границам" = "Crop image by spatial bounds";
"Обрезать спектральный диапазон по каналам" = "Trim spectral range by channels";
"Обрезка выбросов по процентилям" = "Outlier clipping by percentiles";
"Обрезка длин волн" = "Wavelength trimming";
"Обрезка области" = "Cropping";
"Ограничить значения диапазоном" = "Limit values to range";
"Оценка среднего и дисперсии…" = "Estimating mean and variance…";
"Ошибка выделения памяти" = "Memory allocation error";
"Переставить оси массива в выбранный порядок HWC" = "Reorder array axes to selected HWC order";
"По ближайшему соседу" = "Nearest neighbor";
"По каналам: " = "By channels: ";
"По часовой стрелке" = "Clockwise";
"Повернуть изображение на 90°, 180° или 270°" = "Rotate image by 90°, 180°, or 270°";
"Поворот" = "Rotation";
"Поврежденные данные" = "Corrupted data";
"Подготовка данных для автоподбора…" = "Preparing data for auto-crop…";
"Поддерживаются только PNG, JPG и BMP файлы" = "Only PNG, JPG, and BMP files are supported";
"Поканальная нормализация" = "Per-channel normalization";
"Полный кадр" = "Full frame";
"Применение сохранённых параметров…" = "Applying saved parameters…";
"Применить нормализацию к данным" = "Apply normalization to data";
"Применить нормализацию отдельно к каждому каналу" = "Apply normalization separately to each channel";
"Проекция и нормализация…" = "Projection and normalization…";
"Пунктирная" = "Dashed";
"pipeline.alignment.error.already_in_progress" = "Wait until the current alignment computation finishes";
"content.alignment.processing.title" = "Homography search";
"Размер файла не соответствует заголовку" = "File size does not match header";
"Разрешить доступ" = "Grant access";
"Расчёт ковариации…" = "Computing covariance…";
"Референс" = "Reference";
"Сбор статистики…" = "Collecting statistics…";
"Сверху вниз" = "Top to bottom";
"Слева направо" = "Left to right";
"Снизу вверх" = "Bottom to top";
"Собственные векторы…" = "Eigenvectors…";
"Сплайн" = "Spline";
"Сплошная" = "Solid";
"Справа налево" = "Right to left";
"Стандартизация: (x - mean) / std" = "Standardization: (x - mean) / std";
"Точечная" = "Dotted";
"Транспонирование" = "Transpose";
"Усреднение диапазонов λ для R/G/B" = "Averaging lambda ranges for R/G/B";
"Файл не найден" = "File not found";
"Файл не содержит 3D гиперкуб" = "File does not contain a 3D hypercube";
"белая REF" = "white REF";
"чёрная REF" = "black REF";
"белая" = "white";
"чёрная" = "black";
"Автоматический поиск области белого" = "Automatic white-area search";
"Открыть анализ сцены" = "Open scene analysis";
"Откроется окно RGB-синтеза, найдутся кандидаты белой области с учётом засветок, однородности и контраста." = "An RGB synthesis window will open, and white-point candidates will be found with glare, spectral uniformity, and contrast checks.";
"Откройте ГСИ перед автопоиском белой области" = "Open an HSI cube before automatic white-area search";
"Подготовка данных сцены…" = "Preparing scene data…";
"Подходящие области не найдены" = "No suitable regions found";
"Формирование спектров кандидатов…" = "Building candidate spectra…";
"pipeline.calibration.auto_white.progress_scan" = "Scene analysis: %1$d / %2$d";
"pipeline.calibration.auto_white.progress_done" = "Candidates found: %d";
"pipeline.calibration.auto_white.candidate_name" = "Auto white area #%1$d (%2$d,%3$d %4$dx%5$d)";
"pipeline.calibration.auto_white.title" = "Automatic white-area search";
"pipeline.calibration.auto_white.reanalyze" = "Run again";
"pipeline.calibration.auto_white.evaluated" = "Windows evaluated: %1$d / %2$d";
"pipeline.calibration.auto_white.rejected_glare" = "Rejected due to glare: %d";
"pipeline.calibration.auto_white.candidates" = "Candidates";
"pipeline.calibration.auto_white.candidate_title" = "Candidate %d";
"pipeline.calibration.auto_white.coords" = "x=%1$d, y=%2$d, %3$dx%4$d";
"pipeline.calibration.auto_white.select_hint" = "Select a region in the list or on the image";
"pipeline.calibration.auto_white.apply" = "Set white point";
"pipeline.calibration.auto_white.not_found" = "Could not find suitable white-point regions";
"pipeline.calibration.auto_white.no_preview" = "No RGB preview";
"pipeline.calibration.auto_white.metric.total" = "Total score";
"pipeline.calibration.auto_white.metric.brightness" = "Brightness";
"pipeline.calibration.auto_white.metric.homogeneity" = "Homogeneity";
"pipeline.calibration.auto_white.metric.flatness" = "Spectral flatness";
"pipeline.calibration.auto_white.metric.dispersion" = "Spectral dispersion";
"pipeline.calibration.auto_white.metric.contrast" = "Contrast";
"pipeline.calibration.auto_white.metric.glare" = "Glare penalty";
"pipeline.calibration.auto_white.spectrum" = "Region mean spectrum";
"pipeline.calibration.auto_white.lambda_axis" = "Wavelength (nm)";
"pipeline.calibration.auto_white.channel_axis" = "Channel";
"Пресет автопоиска" = "Auto-search preset";
"Сбалансированный" = "Balanced";
"Приоритет Spectralon" = "Spectralon priority";
"Низкая освещённость" = "Low light";
"Сильные засветки" = "Harsh highlights";
"Сбалансированное окно" = "Balanced window";
"Мелкие цели" = "Small targets";
"Крупные панели" = "Large panels";
"Плотное сканирование" = "Dense scan";
"Быстрое сканирование" = "Fast scan";
"pipeline.calibration.auto_white.preset_used" = "Preset: %@";
"pipeline.calibration.auto_white.preset.desc.balanced" = "General-purpose mode for most scenes.";
"pipeline.calibration.auto_white.preset.desc.spectralon" = "Prioritizes larger neutral panels (e.g., Spectralon), de-emphasizes tiny bright details.";
"pipeline.calibration.auto_white.preset.desc.low_light" = "For dark scenes: softer brightness and glare thresholds.";
"pipeline.calibration.auto_white.preset.desc.harsh_light" = "For difficult lighting: stronger glare and specular suppression.";
"pipeline.calibration.auto_white.window_preset.title" = "Sliding-window preset";
"pipeline.calibration.auto_white.window_preset.desc.balanced" = "Balanced scale and stride for typical scenes.";
"pipeline.calibration.auto_white.window_preset.desc.small_targets" = "Smaller windows with denser step to detect compact white targets.";
"pipeline.calibration.auto_white.window_preset.desc.large_panels" = "Larger windows and coarser stride for calibration panels.";
"pipeline.calibration.auto_white.window_preset.desc.dense_scan" = "Most detailed search across scales; slower but more exhaustive.";
"pipeline.calibration.auto_white.window_preset.desc.fast_scan" = "Fewer window sizes and larger step for faster analysis.";
"pipeline.calibration.auto_white.advanced.title" = "Advanced factor settings";
"pipeline.calibration.auto_white.advanced.range_hint" = "Range 0.00-2.00";
"pipeline.calibration.auto_white.factor.reset" = "Reset influences";
"pipeline.calibration.auto_white.factor.brightness" = "Brightness";
"pipeline.calibration.auto_white.factor.local_homogeneity" = "Spatial homogeneity";
"pipeline.calibration.auto_white.factor.flatness" = "Spectral flatness";
"pipeline.calibration.auto_white.factor.dispersion" = "Low spectral dispersion";
"pipeline.calibration.auto_white.factor.spectral_homogeneity" = "Spectral homogeneity";
"pipeline.calibration.auto_white.factor.contrast" = "Region contrast";
"pipeline.calibration.auto_white.factor.neutrality" = "Neutrality (achromaticity)";
"pipeline.calibration.auto_white.factor.area" = "Region size";
"pipeline.calibration.auto_white.factor.shape" = "Region shape";
"pipeline.calibration.auto_white.factor.glare_penalty" = "Glare penalty";
"mask.layers.context.merge_selected" = "Merge selected layers…";
"mask.layers.merge.sheet.title" = "Merge Layers";
"mask.layers.merge.sheet.selected_count" = "Selected layers: %d";
"mask.layers.merge.sheet.name" = "New class name";
"mask.layers.merge.sheet.color" = "New class color";
"mask.layers.merge.sheet.keep_originals" = "Keep original layers after merge";
"mask.layers.merge.sheet.merge" = "Merge";
